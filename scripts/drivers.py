#!/usr/bin/env -S python3 -B

# search and add python modules under the given directory to the search path.
# It also instatiates the top_module, assuming that it is a class with the same
# name as the file that contains it.
import argparse
import os
import sys


# Search for files under the given directory using a breadth-first search
def bfs_search_files(search_path):
    dirs = [search_path]
    return_values = []
    # while there are dirs to search
    while len(dirs):
        nextDirs = []
        for parent in dirs:
            # Create a tuple for this directory containing the path and a list
            # of files in it
            dir_tuple = (parent, [])
            return_values.append(dir_tuple)
            # Scan this dir
            for f in os.listdir(parent):
                # if there is a dir, then save for next ittr
                # if it is a file then save it in dir_tuple
                ff = os.path.join(parent, f)
                if os.path.isdir(ff):
                    nextDirs.append(ff)
                else:
                    dir_tuple[1].append(f)
        # once we've done all the current dirs then
        # we set up the next itter as the child dirs
        # from the current itter.
        dirs = nextDirs
    return return_values


# Remove registers with address ranges from list
def filter_table(table):
    filtered_table = [i for i in table if i["log2n_items"] == 0]
    return filtered_table


def write_linux_swheader(mkregs_obj, table, out_dir, top):
    os.makedirs(out_dir, exist_ok=True)
    fswhdr = open(f"{out_dir}/{top}.h", "w")

    fswhdr.write("/* This file was automatically generated by:\n")
    fswhdr.write(" * `write_linux_swheader` method of `mkregs.py`\n")
    fswhdr.write(" */\n\n")

    core_prefix = top.upper()

    fswhdr.write(f"#ifndef H_{core_prefix}_H\n")
    fswhdr.write(f"#define H_{core_prefix}_H\n\n")
    fswhdr.write(f'#define {core_prefix}_DRIVER_NAME "{top}"\n')
    fswhdr.write(f'#define {core_prefix}_DRIVER_CLASS "{top}"\n')
    fswhdr.write(f'#define {core_prefix}_DEVICE_FILE "/dev/{top}"\n')
    fswhdr.write(
        f'#define {core_prefix}_DEVICE_CLASS "/sys/class/" {core_prefix}_DRIVER_CLASS "/" {core_prefix}_DRIVER_NAME\n\n'
    )

    for row in table:
        fswhdr.write(
            f'#define {core_prefix}_SYSFILE_{row["name"]} {core_prefix}_DEVICE_CLASS "/{row["name"].lower()}"\n'
        )
    fswhdr.write("\n")

    fswhdr.write("//used address space width\n")
    fswhdr.write(f"#define {core_prefix}_CSRS_ADDR_W {mkregs_obj.core_addr_w}\n\n")

    fswhdr.write("//Addresses\n")
    for row in table:
        name = row["name"]
        if "W" in row["type"] or "R" in row["type"]:
            fswhdr.write(f"#define {core_prefix}_{name}_ADDR {row['addr']}\n")

    fswhdr.write("\n//Data widths (bit)\n")
    for row in table:
        name = row["name"]
        n_bits = row["n_bits"]
        n_bytes = int(mkregs_obj.bceil(n_bits, 3) / 8)
        if n_bytes == 3:
            n_bytes = 4
        if "W" in row["type"] or "R" in row["type"]:
            fswhdr.write(f"#define {core_prefix}_{name}_W {n_bytes*8}\n")

    fswhdr.write(f"\n#endif // H_{core_prefix}_H\n")

    fswhdr.close()


def write_linux_sysfs_header(table, out_dir, top, multi=False):
    # multi: generate sysfs_header for multiple hardware device support
    # NOTE: assumes struct iob_data* in dev->platform_data
    table = filter_table(table)
    os.makedirs(out_dir, exist_ok=True)
    if multi:
        fswhdr = open(f"{out_dir}/{top}_sysfs_multi.h", "w")
    else:
        fswhdr = open(f"{out_dir}/{top}_sysfs.h", "w")

    fswhdr.write("/* This file was automatically generated by:\n")
    fswhdr.write(" * `write_linux_sysfs_header` method of `mkregs.py`\n")
    fswhdr.write(" */\n\n")

    core_prefix = top.upper()

    fswhdr.write(f"#ifndef H_{core_prefix}_SYSFS_H\n")
    fswhdr.write(f"#define H_{core_prefix}_SYSFS_H\n\n")

    # sysfs show / store functions
    fswhdr.write("// Sysfs show/store functions\n")
    fswhdr.write(
        "static ssize_t sysfs_enosys_show(struct device *dev, struct device_attribute *attr, char *buf) {\n"
    )
    fswhdr.write("\treturn -ENOSYS;\n")
    fswhdr.write("}\n\n")
    fswhdr.write(
        "static ssize_t sysfs_enosys_store(struct device *dev, struct device_attribute *attr, const char __user *buf, size_t count) {\n"
    )
    fswhdr.write("\treturn -ENOSYS;\n")
    fswhdr.write("}\n\n")

    for row in table:
        name = row["name"]
        reg_name = name.lower()
        if "W" in row["type"]:
            # top, reg_name
            fswhdr.write(
                f"static ssize_t sysfs_{reg_name}_store(struct device *dev, struct device_attribute *attr, const char __user *buf, size_t count) {{\n"
            )
            fswhdr.write("\tu32 value = 0;\n")
            if multi:
                fswhdr.write(
                    f"\tstruct iob_data *{top}_data = (struct iob_data*) dev->platform_data;\n"
                )
            fswhdr.write(f"\tif (!mutex_trylock(&{top}_mutex)) {{\n")
            fswhdr.write('\t\tpr_info("Another process is accessing the device\\n");\n')
            fswhdr.write("\t\treturn -EBUSY;\n")
            fswhdr.write("\t}\n")
            fswhdr.write('\tsscanf(buf, "%u", &value);\n')
            if multi:
                fswhdr.write(
                    f"\tiob_data_write_reg({top}_data->regbase, value, {top.upper()}_{reg_name.upper()}_ADDR, {top.upper()}_{reg_name.upper()}_W);\n"
                )
            else:
                fswhdr.write(
                    f"\tiob_data_write_reg({top}_data.regbase, value, {top.upper()}_{reg_name.upper()}_ADDR, {top.upper()}_{reg_name.upper()}_W);\n"
                )
            fswhdr.write(f"\tmutex_unlock(&{top}_mutex);\n")
            fswhdr.write(f'\tpr_info("[{top}] Sysfs - Write: 0x%x\\n", value);\n')
            fswhdr.write("\treturn count;\n")
            fswhdr.write("}\n\n")
        elif "R" in row["type"]:
            # show function
            fswhdr.write(
                f"static ssize_t sysfs_{reg_name}_show(struct device *dev, struct device_attribute *attr, char *buf) {{\n"
            )
            if multi:
                fswhdr.write(
                    f"\tstruct iob_data *{top}_data = (struct iob_data*) dev->platform_data;\n"
                )
                fswhdr.write(
                    f"\tu32 value = iob_data_read_reg({top}_data->regbase, {top.upper()}_{reg_name.upper()}_ADDR, {top.upper()}_{reg_name.upper()}_W);\n"
                )
            else:
                fswhdr.write(
                    f"\tu32 value = iob_data_read_reg({top}_data.regbase, {top.upper()}_{reg_name.upper()}_ADDR, {top.upper()}_{reg_name.upper()}_W);\n"
                )
            fswhdr.write(f'\tpr_info("[{top}] Sysfs - Read: 0x%x\\n", value);\n')
            fswhdr.write('\treturn sprintf(buf, "%u", value);\n')
            fswhdr.write("}\n\n")

    # DEVICE_ATTR(name, 0600, sysfs_show, sysfs_store)
    fswhdr.write("// Device attributes\n")
    for row in table:
        # attr name and permissions
        reg_name = row["name"].lower()
        fswhdr.write(f"DEVICE_ATTR({reg_name}, 0600,")

        # sysfs show function
        if "R" in row["type"]:
            fswhdr.write(f" sysfs_{reg_name}_show,")
        else:
            fswhdr.write(" sysfs_enosys_show,")

        # sysfs store function
        if "W" in row["type"]:
            fswhdr.write(f" sysfs_{reg_name}_store);\n")
        else:
            fswhdr.write(" sysfs_enosys_store);\n")

    fswhdr.write("\n")

    # probe / remove functions
    fswhdr.write("// Probe / Remove functions\n")
    fswhdr.write(
        f"static int {top}_create_device_attr_files(struct device *device) {{\n"
    )
    fswhdr.write("\tint ret = 0;\n")
    for row in table:
        fswhdr.write(
            f"\tret |= device_create_file(device, &dev_attr_{row['name'].lower()});\n"
        )
    fswhdr.write("\treturn ret;\n")
    fswhdr.write("}\n\n")

    fswhdr.write(
        f"static void {top}_remove_device_attr_files(struct iob_data *{top}_data) {{\n"
    )
    for row in table:
        fswhdr.write(
            f"\tdevice_remove_file({top}_data->device, &dev_attr_{row['name'].lower()});\n"
        )
    fswhdr.write(f"\tdevice_destroy({top}_data->class, {top}_data->devnum);\n")
    fswhdr.write("\treturn;\n")
    fswhdr.write("}\n")

    fswhdr.write(f"\n#endif // H_{core_prefix}_SYSFS_H\n")
    fswhdr.close()


# Add python modules search paths for every module
search_path = "."
print(f"Searching for modules under '{search_path}'...", file=sys.stderr)
found_modules = []
for filepath, files in bfs_search_files(search_path):
    for filename in files:
        if filename.endswith(".py") and filename not in found_modules:
            sys.path.append(filepath)
            found_modules.append(filename)

print("IOb Linux Drivers Script")

# parse arguments
# ./drivers.py [iob_module] -o [output_dir]
parser = argparse.ArgumentParser(
    prog="drivers.py",
    description="""Python script to generate C header files for linux driver develop.""",
)
parser.add_argument("top_module", help="Target iob module")
parser.add_argument(
    "-o",
    "--output",
    type=str,
    nargs="?",
    default=".",
    help="Output header path",
)
args = parser.parse_args()

exec("import " + args.top_module)

# instantiate top_module
top_module = vars(sys.modules[args.top_module])[args.top_module]

# get mkregs object and register table
top_module.confs = []
top_module.regs = []
top_module._setup_confs()
top_module._setup_regs()
top_module._setup_purpose = []
mkregs_obj, reg_table = top_module._build_regs_table()

# generate linux headers
write_linux_swheader(mkregs_obj, reg_table, args.output, args.top_module)
write_linux_sysfs_header(reg_table, args.output, args.top_module, multi=False)
write_linux_sysfs_header(reg_table, args.output, args.top_module, multi=True)
